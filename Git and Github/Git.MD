# GIT NOTE

## Linki
[Podstawowe polecenia](https://training.github.com/downloads/pl/github-git-cheat-sheet/)

[GIT Manual](https://git-scm.com/book/en/v2)

[GIT Manual PL](https://git-scm.com/book/pl/v2)

[GIT Aliases](https://github.com/ohmyzsh/ohmyzsh/blob/master/plugins/git/README.md#aliases)

[GIT School Visualizing](https://git-school.github.io/visualizing-git/#free)


```bash
git help
```

## Czym jest GIT

> Git jest systemem kontroli wersji *VCS* - Version Control System, rejestruje wprowadzone zmiany w pliku lub w plikach w czasie.

Umo偶liwia:
* Cofanie zmian w pliku lub caego projektu.
* Umo偶liwia podgld zmian kt贸re zostay wprowadzone na przestrzeni czasu.
* Umo偶liwia podgld kto wprowadzi zmiany.
* Umo偶liwia podgld powodu wprowadzonej zmiany.
* Mo偶e by wykorzystany dla dowolnego typu pliku, nie tylko dla kodu 藕r贸dowego.

## Zalety
* Szybko
* Mdry
* Elastyczny
* Bezpieczny

## Wady
* Brak kontroli dostpu.
* Brak blokowania pliku nad kt贸rym si pracuje (czasem zaleta bo lepiej rozwiza konflikty ni偶 blokowa prac).
* Problem z plikami du偶ych rozmiar贸w (pobieranie wszystkich z centralnego repozytorium).
* Nie jest zbyt przyjazny dla u偶ytkownika (wysoki pr贸g wejcia)

## Instalacja i konfiguracja

### Windows
- Instalacja za pomoc instalatora [Instalator](https://git-scm.com/download/win)
- Instalacja za pomoc `winget install git`

### Systemy linux oparte na dystrybucji debian

```bash
sudo apt update
sudo apt upgrade
sudo apt install git
```

## Konfiguracja
Kolejno pobierania konfiguracji:
1. Folder projektu
2. Folder u偶ytkownika
3. Folder systemowy

```bash
git config --local user.name
git config --global user.name
git config --system user.name
```

Konfiguracja adresu email i nazwy u偶ytkownika:

```bash
# Ustawienie to偶samoci
git config --global user.name "John Doe"
git config --global user.email johndoe@example.com

# Ustawienie visual studio jako domylny edytor
git config --global core.editor "code --wait"

# sprawdzenie bie偶cych ustawie
git config --list
# Wywietlenie konfiguracji wraz z informacj o 藕r贸dle jej pochodzenia
git config --list --show-origin
```

> Ustawienie vsc jako edytor podgldu zmian

```bash
# .gitconfig w katalogu u偶ytkownika
git config --global -e

# lub
git config --edit --global
```

```conf
[diff]
    tool = vscode-diff
[difftool]
	prompt = false
[difftool "vscode-diff"]
    cmd = code --wait --diff $LOCAL $REMOTE
```

### Instalacja git-aliases dla powershell

```powershell
Install-Module git-aliases -Scope CurrentUser -AllowClobber

# jeli konieczna jest zmiana uprawnie ze wzgldu na bd podczas instalacji
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
```

Otwieramy plik profilu i dodajemy import
```powershell
code $PROFILE
```

```conf
# dodajemy linie
Import-Module git-aliases -DisableNameChecking
```
## Przepyw pracy

1. Pobranie kodu z serwera kontroli wersji
2. Dodanie wasnego kodu
3. Pobranie zmian z serwera jeli kto pracowa na tym samym pliku
4. Rozwizanie konflikt贸w
5. Wysanie zmian na serwer

## Podstawy

### Stany plik贸w

> Working Area
Miejsce w kt贸rym przechowywane s bie偶ce pliki i foldery (folder roboczy projektu)
Lokalizacja na dysku gdzie pliki s tworzone, modyfikowane lub kasowane. Po zatwierdzeniu zmian pliki trafiaj do repozytorium.

> Index
Miejsce do kt贸rego trafiaj pliki przed zatwierdzeniem (commitem)

Index znajduje si pomidzy obszarem roboczym a repozytorium. Pliki nie s przenoszone bezporednio z indeksu do repozytorium, najpierw trafiaj do indeksu nazywanego obszarem przejciowym **staged area**.
Polecenie `add` dodaje pliki do indeksu a `commit` przenosi je do repozytorium.

> Repozytorium
Cae repozytorium Git przechowywane jest w katalogu `.git`. Przechowuje on zatwierdzenia oraz ca historie projektu.
Katalog `objects` przechowuje r贸偶ne typy:

> Obiekty dzielimy na:
- blob (zawarto plik贸w w pewnym momencie historii)
- tree (reprezentuj foldery w projekcie)
- commit (s tworzone za ka偶dym razem kiedy wykonujemy zatwierdzenie commit)

:bulb: Wszystkie te obiekty s niezmienne, mo偶na je dodawa, usuwa ale nigdy nie mo偶na ich zmieni.

> Stash
Schowek w kt贸rym mo偶emy umieszcza plik kt贸re nie s dodane jeszcze do indeksu

Zatwierdzenie to migawka obszaru roboczego w danym momencie. R贸偶ne zatwierdzenia mog dzieli wsp贸lne obiekty.
W historii ka偶de zatwierdzenie wskazuje na swojego rodzica.

Gazie s referencjami do okrelonych zatwierdze (commit). Zatwierdzenie mo偶e nale偶e do wielu gazi.

Wska藕nik `HEAD` jest tylko jeden, zwykle wskazuje na bie偶c ga藕 ze znajdujcym si na niej zatwierdzeniem

Po dodaniu nowego pliku do obszaru roboczego Git sygnalizuje 偶e widzi nowy plik ale nie jest jeszcze przez niego ledzony (untracked).
Aby git m贸g go ledzi konieczne jest dodanie go do indeksu za pomoc `git add <file_name`.

> :exclamation: Jeli plik zosta dodany do ledzenia, a nastpnie zmodyfikowany konieczne jest jego ponowne dodanie przed zatwierdzeniem.
Polecenie `git add` nie tylko dodaje nowe pliki ale tworzy zamra偶a r贸wnie偶 obecny stan pliku kt贸ry znajdzie si w kolejnej migawce/commit

G贸wna ga藕 to `Main` (dawniej Master)

Repozytoria
- Lokalne (Local)
- Zdalne (Origin)

## Przepyw pracy
- Inicjalizacja repozytorium w katalogu roboczym
- Dodanie plik贸w kt贸re chcemy ledzi
- Zmiany w pliku znajdujcego si w katalogu roboczym
- Dodanie zmian do indeksu (`git add <file_name>)`
- Zatwierdzenie zmian i dodanie zatwierdzenia do repozytorium (`git commit`)

Zwykle przepyw pracy odbywa si ze strony lewej do prawej
`working directory` -> `index` -> `repository`

Jeli chcemy zmieni kierunek przepywu mo偶emy wykorzysta polecenie `git checkout`.

Pozwala ono na:
- Zmian poo偶enia wska藕nika `HEAD` na inna ga藕 (porednio bdzie wskazywao na wybrany commit na tej gazi)
- Pobierze dane z tego zatwierdzenia i przywr贸ci (skopiuje) z niego pliki do katalogu roboczego i indeksu (pliki we wszystkich obszarach s identyczne i zgodne z commitem na kt贸ry wskazuje `HEAD`).



### Detached HEAD
Znacznik `HEAD` zwykle wskazuje na branch, ale Git mo偶e pracowa r贸wnie偶 w trybie `odczonej gowy`, oznacza to 偶e wska藕nik `Head` nie zawsze musi wskazywa na ga藕. Mo偶e wskazywa na konkretny commit poprzez polecenie `git checkout <hash_commit>` (mo偶e to by aktualny commit).
Mo偶emy wtedy dodawa kod i eksperymentowa, jeli nie zdecydujemy si na zapisanie zmian wska藕nik przeczamy na ga藕 np. `main` poprzez `git switch main`
Niezapisane commity przestan po jakim czasie istnie w bazie danych wyczyszczone przez **garbage collector**, mo偶emy je jednak zapisa na nowej gazi korzystajc z ich **hash** do p贸ki s widoczne w logach konsoli.
W trybie odczonej gowy nadal mo偶emy tworzy commity, nale偶y w贸wczas przenie si na wybrany commit `git checkout <hash_commit` i przypi go do jakiego brancha np. `git switch -c <branch_name` lub lub wykona `merge` do istniejcej gazi.

Miejsce wska藕nika mo偶emy sprawdzi za pomoc `git branch`.


## REBASE
> :exclamation: Nie nale偶y u偶ywa `rebase` na gaziach publicznych

* Oczyszczanie historii gazi przed jej wysaniem
* Pobranie zmian z jednej do drugiej gazi bez `merge`

### Zmiany historii lokalnej przed wysaniem zmian do zdalnego repozytorium

# Dodanie kolejnych zmian w projekcie / pliku do wczeniejszego commit
```bash
git commit --amend
```
:bulb: Podczas commit z parametrem `amend` git nie modyfikuje ostatniego commit poniewa偶 s one niezmienne zamiast tego tworzy now kopie z dodan zawartoci i przenosi nia ni znacznik `HEAD`, stary commit zostanie w przyszoci usunity przez **garbage collector**. Dziaa tylko dla ostatniego zatwierdzenia.

:exclamation: Polecenie zmienia historie wic stosujemy tylko na gaziach lokalnych.

Jeli chcemy naprawi/zmieni historie wczeniejszych commit贸w musimy upewni si 偶e zmiany nie zostay wysane jeszcze do repozytorium zdalnego.

<!-- Tworzymy nowy commit kt贸ry w kt贸rym dodajemy wymagane zmiany a nastpnie wykorzystujemy polecenie rebase w trybie **interactive** -->

:bulb: Interaktywny **rebase** mo偶emy wykorzysta do edycji/poprawy/scalenia historii przed wysaniem do zdalnego repozytorium.

```bash
# wybieramy commit poni偶ej tego od kt贸rego chcemy zmieni histori
git rebase -i <hash_commit>
```


### MERGE i REBASE

> Narzdzie scalania
```bash
git mergetool
```

Scalanie `merge` polega na poczeniu dw贸ch gazi w jedn, czyli na. wczenie gazi z nowymi funkcjonalnociami do gazi `main`. Gdy jestemy na gazi main wykonujemy czenie za pomoc komendy `git marge <feature_branch>`. czenie za pomoc samego `merge` tworzy now migawk kt贸ra jest wsp贸lna dla obydwu gazi.


Innym sposobem czenia jest `rebase`.
 Polega to na zacigniciu zmian z poziomu `feature` z gazi `main` poprzez `git rebase master`, a nastpnie wykonania scalenia z poziomu gazi `main` poleceniem `git merge feature`. Przy tym sposobie commity zachowuj swoj histori zmian. Przy stosowaniu tego sposobu wa偶ne jest czste zaciganie/rebase zmian z gazi master aby unika du偶ej iloci konflikt贸w przy czeniu.

:exclamation: Historia jest zachowana na jednej lini czasowej ale nie odzwierciedla dokadnie tego co si dziao w projekcie


- `git switch main` Aktualizujemy main `git pull --rebase` (przy korzystaniu z repozytorium zdalnego)
- Zamieniamy branch `git switch feature` a nastpnie `git rebase main`
- Zmieniamy ga藕 na main `git switch main` i scalamy `git merge feature`


### Cherry Pick

> `git cherry-pick` skopiowa commita (bd藕 kilka commit贸w) z jednego brancha na drugi

```bash
git cherry-pick <hash_commit>

# po naprawieniu konfliktu
git cherry-pick --continue
```

### TAGI


Tagi to rodzaj zakadki przy pomocy kt贸rych mo偶emy oznacza wa偶ne commity. Najczciej oznaczmy commity kt贸re wskazuj koniec pracy nad dan funkcjonalnoci lub kolejn wersj aplikacji.

Tagi dzielimy na dwie kategorie
* lekkie (bez adnotacji)
* z adnotacj (tworz w strukturze dodatkowe miejsce na zapisanie dodatkowych danych)

Flaga `a` dodaje dodatkowe adnotacje np. o autorze

```bash
# Dodanie tag
# a - annotation
# m - message
git tag <tag_name> -a -m <message>

# Dodanie tag do dowolnego commit mo偶na doda r贸wnie偶 -a -m
## git tag v1.0 3432340
git tag <tag_name> <hash_commit>

# Wywietlenie tag贸w
git tag

# Tag bez adnotacji
git tag <tag_name>


# dodatkowe informacje o commit na kt贸ry wskazuje TAG
git show <tag_name>

# Usunicie Tagu
git tag -d <tag_name>

# Wysanie samych tag贸w do zdalnego repozytorium
git push --tags

# Usuwanie tagu ze zdalnego repozytorium
## git push -d origin v1.0
git push -d <remote_repository_name> <tag_name>
```

## Polecenia systemowe

```bash
# aktualny katalog roboczy
pwd
```

## Praca z GIT Command Line

---
> Inicjalizacja nowego repozytorium GIT
```bash
git init

# tworzenie pustego repozytorium bez folderu roboczego
git init --bare
```
> Dodanie wszystkich plik贸w do ledzenia
```bash
git add .
```

> Zatwierdzenie zmian z komentarzem
```bash
git commit -m "Init Commit"
```

> Dodanie lokalnego repozytorium do repozytorium zdalnego GitHub
```bash
git remote add origin https://github.com/{user}/{repo-name}.git

# Zmiana nazwy gazi
git branch -M main
git push -u origin main
```
## Podstawowe komendy
> Sprawdza status
```bash
# Wersja pena
## gst
git status

# Wersja skr贸cona
## gss
git status -s

# Szczeg贸y commita
git show <hash_commit>

```

> Sprawdzenie historii commit
```bash
# wszystkie zmiany
## glgg
git log

# liczba ostatnich zmian
git log -3

# zmiany w jednej lini
## glog
git log --oneline

# pokazuje log dla wybranej gazi
git log <branch_name> --online

# zmiany w jednej linii z przedstawieniem graficznym gazi
git log --graph --decorate --oneline

# zmiany dla commit na kt贸rym jest znacznik HEAD
git log HEAD

# zmiany dla commit na kt贸rym jest rodzicem dla aktualnego HEAD
git log HEAD^

# polecenia dziaaj dobrze w przypadku kiedy commity maj jednego rodzica
# rodzic rodzica
git log HEAD^^
#lub cofnij si o dwa commity od HEAD i go poka偶
git log HEAD~2


# zmiany szczeg贸owe
## glg
git log --stat

# zmiany wraz ze ze zmodyfikowanymi wartociami w plikach
## glgp
git log --stat -p
```
> Przegldanie i odzyskiwanie referencji ze zmian

Reflog pozwala na dokadne przegldanie historii (po kt贸rych elementach porusza si znacznik `HEAD`). mo偶emy z niego odzyska dane np. hash zmian kt贸re zostay wprowadzone poprzez wykorzystanie interaktywnego rebase. Dane s widoczne do momentu zebrania ich przez **garbage collector**.
Reflog zawiera dane lokalne.

```bash
git reflog
```


> Sprawdzenie jaka kt贸re commit zmieniay warto zawarto pliku

```bash
git blame <file_name>
```

Pliki mog by zmodyfikowane w r贸偶nych miejscach

| Staged | Modified | File Name |
| ------ | -------- | --------- |
| M      |          | File1     |
| M      | M        | File2     |
| A      |          | File3     |
| ?      | ?        | File4     |

Oznaczenia liter
* `A` - Nowy plik w staged
* `M` - Zmodyfikowany plik
* `?` - Nowy nie ledzony plik w katalogu roboczym


> Dodawanie pliku i zmian do **staging**

:bulb: Wszystko co znajduje si w staging trafi do nastpnego commit

```bash
git add .
git add -A
git add <file_name>
git add folder/
```

Mo偶emy r贸wnie偶 wybra kt贸re zmiany chcemy doda do staging z pojedynczego pliku kt贸ry zosta zmodyfikowany.

```bash
git add --patch <file_name>
```

> Commit zmian
```bash
git commit -m "Message"

# Jeli pliki s dodane/track mo偶emy przy zmianach wykorzysta flag -a
# gcam
git commit -am "Message"
```
> Wycofanie wprowadzonych zmian

Istniej r贸偶ne sposoby przywracania projektu jak r贸wnie偶 pojedynczego pliku.

> `git checkout` - su偶y do przywracania projektu lub pliku do wczeniejszego stanu.

Przesuwa wska藕nik `HEAD` na wskazany commit.

W katalogu zostan wczytane pliki z okrelonego commit.

Jeli zdecydujemy si na u偶ycie go na pliku zostanie wczytana jego wersja z podanego commit.

Przy zastosowaniu polecenia `git checkout <hash_commit>` przechodzimy w tryb `detached HEAD` (tryb odczonej gowy ). Pozwala to przeglda i eksperymentowa bez zapisywania zmian. Jeli jednak zdecydujemy si na ich zapisanie mo偶emy u偶y komendy `git checkout -b <branch_name>`.



``` bash
# Przywr贸cenie wybranego commit
git checkout <hash_commit>

# zapisanie zmian na wybranej gazi
git checkout -b <branch_name>

# powr贸t na wybran ga藕
git checkout master

# nowsza wersja
git switch master
```

> `git reset`


Polecenie zmienia bie偶c ga藕 a co si z tym wi偶e zmienia r贸wnie偶 bie偶ce zatwierdzenie.
`git reset` to wyspecjalizowane polecenie dziki kt贸remu mo偶emy przenie si na dowolny commit (poprzez zmian gazi). Zmiana jest dokonywana razem ze znacznikiem `HEAD`. Aktualnym zatwierdzeniem jest to wybrane przez `git reset`.

:exclamation: Powoduje modyfikacj historii commit (usuwa p贸藕niejsze commit). Zmiany nale偶y wycofa przed wysaniem zmian do zdalnego repozytorium.

Jednym ze sposob贸w u偶ycia `git reset` jest powr贸cenie do wczeniejszej wersji projektu, cofnicie gazi w czasie bez zachowania p贸藕niejszej historii zatwierdze.
Jeli chcemy przywr贸ci pliki do dokadnie takiej wersji jak w migawce we wszystkich obszarach skorzystamy z opcji `--hard`.
Poniewa偶 nie ma ju偶 odniesie do p贸藕niejszych zatwierdze (commit) zostan one wyczyszczone po jakim czasie przez `garbage collector`.

```bash
# Przesunie tylko ga藕 i nie zmodyfikuje pozostaych obszar贸w
git reset --soft

#  skopiuje zmiany z repository do index (domylnie jeli nie dodamy 偶adnego parametru)
git reset --mixed

# skopiuje zmiany z repozytorium do wszystkich pozostaych obszar贸w (working area, index)
git reset --hard

# wybrany plik
git checkout <file_name>
```

`git reset` mo偶emy r贸wnie偶 u偶y w sytuacji gdy wprowadzilimy ju偶 zmiany do indeksu za pomoc `git add` i chcemy je wycofa.
Jestemy przenoszeni do zatwierdzenia na kt贸re wskazuje znacznik `HEAD` a on wskazuje na ostatni wykonany commit w tej sytuacji ga藕 tak naprawd nie jest przesuwana poniewa偶 wska藕nik cay czas si tam znajduje.

Je偶eli nie zastosujemy 偶adnej opcji domylnie bdzie zastosowany `--mixed` i zmiany z repozytorium (z bie偶cego commit) znajd si tylko w obszarze index (plik bdzie mia status `modified`).

```bash
git reset HEAD

# Przywr贸cenie wszystkich plik贸w z repository do working directory
git reset HEAD --hard

```

Jeli mamy wicej ni偶 jeden plik i chcemy zastosowa przywr贸cenie tylko na mim mo偶emy przenie zmiany z **repozytorium** do **stage** i nie zmienia plik贸w w **working directory** a jedynie plik kt贸ry jest w **staging**.

```bash
# Przywr贸cenie tylko jednego pliku z repository do staging
git reset HEAD <file_name>
```

:exclamation: Niestety nie jest mo偶liwe przywr贸cenie pojedynczego pliku z opcj `--hard` za miast tego nale偶y u偶y (w tym przypadku `checkout` nie spowoduje zmiany `HEAD`)



```bash
git checkout HEAD --hard <file_name>
```

> `git revert` - odwraca zmiany z wybranego commit i zapisuje jako nowy commit

Pozwala bezpiecznie przywraca zmiany kt贸re znajduj si ju偶 w repozytorium **zdalnym**.

:bulb: Nie usuwa nie modyfikuje historii zmian i odwraca zmiany tylko w wybranym commit (wczeniejsze commit pozostaj bez zmian).

```bash
git revert <hash_commit>
```



> Pobieranie zmian ze zdalnego repozytorium

`git pull` to poczenie `git fetch` i `git rebase`

```bash
git pull --rebase

# pobranie wszystkich gazi
git pull --all
```



> Dodanie nowej gazi/branch
```bash
git checkout -b <branch_name>

# nowsza wersja
git switch -c <branch_name>
```

> Zmiana nazwy gazi
```bash
# Zmiana nazwy gazi na kt贸rej si obecnie znajdujemy
git branch -m <new_branch_name>

# zmiana nazwy gazi na kt贸rej si nie znajdujemy
git branch -m <old_branch_name> <new_branch_name>
```

> Przeczenie si pomidzy gaziami/branch
```bash
# git checkout master
git checkout <branch_name>

# nowsza wersja
git switch <branch_name>
```

> Sprawdzenie dostpnych gazi/branch
```bash
git branch
```

> Odkadanie zmian na stos / do schowka (stash)

Jeli wprowadzamy zmiany na gazi w ledzonym pliku i nie s one zatwierdzone przy pomocy commit przy pr贸bie zmiany gazi Git nie pozwoli si na ni przeczy bez ich zatwierdzenia. Jeli nie chcemy tego robi mo偶emy zmiany zapisa w schowku.

Zmiany zostan wycofane (do momentu wczeniejszego commit) i zapisane w schowku.

Przy przenoszeniu danych do schowka s tam zapisywane a do **working directory** s kopiowane pliki z ostatniego zatwierdzenia (commit).

W schowku przechowujemy rzeczy kt贸re musimy odo偶y na pewien czas ale nie chcemy ich dodawa do **staging area**.
W schowku s scalone w jeden identyfikator i jest to schowek wielokrotny.

```bash
git stash

# umieszczenie w schowku z dodanym komunikatem
git stash push -m "message"

# dodaje nieledzone pliki do schowka (domylnie git ignoruje pliki kt贸re nie s ledzone)
git stash --include-untracked
```

> Podejrzenie odo偶onych zmian na stosie wraz z identyfikatorem
```bash
git stash list
# stash@{0}: On feature: Nowa zmiana w schowku


> Aby je przywr贸ci lub doda do innej gazi wykorzystujemy polecenie
Jeli nie podamy identyfikatora polecenia przywr贸c ostatni zmian

```bash
# przywraca zmiany i usuwa je ze stosu
git stash pop

# przywraca zmiany i pozostawia na stosie
git stash apply

# przywr贸cenie konkretnego identyfikatora
git stash pop stash@{0}
```


# wicej szczeg贸贸w
git stash show
```

> Usunicie zmiany ze schowka
```bash
# wyczyszczenie konkretnej zmiany
git stash drop stash@{0}

# wyczyszczenie caego schowka
git stash clear
```

> Utworzenie nowego branch ze zmian zapisanych na stosie
```bash
git stash branch <new_branch_name>
```

> Informacje o zdalnym repozytorium
```bash
git remote
git remote -v

```

> Dodanie zdalnego repozytorium
```bash
git remote add <name> <remote_url>
```

> Wypychanie zmian do zdalnego repozytorium



```bash
# git push origin master
## gp
# -f force, -u default upstream
git push <remote_name> <branch_name>
```

> Zmian nazwy pliku

Gdy wykonany jest commit (wszystkie obszary s identyczne)

Zmiana nazwy poprzez polecenie systemowe:

Polecenie `mv <old_name> <new_name>` zmienia nazw pliku w katalogu roboczym, Git tak zamian widzi jako **usunicie** a nastpnie **dodanie** nowego pliku, a nowo dodane pliki musimy na nowo doda do ledzenia. Gdy dodamy oba plik do indeksu ten ze statusem `new` pojawi si w nim, a ten ze statusem `deleted` zostanie nadpisany `niczym`. Po sprawdzeniu statusu Git zrozumie zmiany i plik pojawi si ze statusem `renamed` (por贸wna zawarto indeksu z repozytorium i zobaczy 偶e maj tak sam zawarto)

```bash
mv <old_file_name> <new_file_name>
```

Jeli chcemy zastosowa operacj zmiany nazwy mo偶emy wykorzysta polecenie wbudowane w Git `git mv <old_name> <new_name>`
```bash
git mv <old_file_name> <new_file_name>
```

> Usunicie pliku

Jeli dodamy lik do indeksu, ale nie wykonamy commit (plik znajduje si w obszarze roboczym i indeksie), git podczas pr贸by usunicia wywietli bd, zapobiega to przypadkowemu usuniciu plik贸w kt贸rych jeszcze nie ma w repozytorium.

W takim przypadku mo偶emy zdecydowa si na usunicie pliku
- Z indeksu `git rm --cached` (pozostawienie go w katalogu roboczym)
- Z indeksu i obszaru roboczego `git rm -f`

Gdy usuniemy plik z indeksu mo偶emy go r贸wnie偶 usun z projektu, git si nim ju偶 nie interesuje.

> Przed dodaniem pliku do repozytorium (nie by wykonany commit)
```bash
# Usuwa plik z indeksu ale zachowuje go w katalogu roboczym, po tym poleceniu plik przestaje by ledzony przez Git
git rm --cached

# Usuwa plik z indeksu oraz katalogu roboczego
git rm -f
```



> Usunicie gazi lokalne
```bash
# Usunicie gazi lokalnie
git branch -d <branch_name>

# usunicie gazi kt贸ra ma zatwierdzenia ale nie zostaa scalona z inn gazi
git branch -D <branch_name>

# Usunicie gazi na zdalnym repozytorium
# git push -d origin <branch_name>
git push -d <remote_name> <branch_name>
```

> Podgld zmian w plikach

Polecenie `git diff` su偶y do por贸wnywania zmian pomidzy trzema obszarami w kt贸rych mog znajdowa si pliki (working directory, index, repository)

```bash
# Narzdzie diftool
git difftool

# por贸wnuje zmiany pomidzy katalogiem roboczym a indeksem
git diff

# por贸wnuje zmiany pomidzy plikami znajdujcymi si w indeksie i tymi kt贸re s w repozytorium
git diff --cached

# co si zmienio od ostatniego commita (zmiany kt贸re s aktualnie w staged i katalogu roboczym)
git diff HEAD

# sprawdzenie r贸偶nicy pomidzy ostatnim commit w plikach znajdujcych si w staged
git diff --staged


# sprawdzenie zmian pomidzy gaziami
git diff <branch1_name> <branch2_name>

# sprawdzenie zmian w konkretnym pliku pomidzy gaziami
git diff <branch1_name> <branch2_name> <file_name>

# sprawdzenie r贸偶nicy pomidzy dwoma commit
git diff <commit> <commit>

# zignorowanie biaych znak贸w
git diff -w

# Sprawdzenie r贸偶nicy pomidzy aktualnym commit o wczeniejszym o dwa zatwierdzenia
git diff HEAD HEAD~2
```



> Scalanie zmian z innej gazi/ **Merge**
```bash
# Przeczamy si na branch do kt贸rego chcemy doda zmiany przewa偶nie main
git checkout main
git merge <branch_name>
```

## Rozwizywanie konflikt贸w

W pliku oznaczenie `<<<HEAD` to zatwierdzenie bie偶ce

> Po rozwizaniu konfliktu

```bash
# po edycji i rozwizaniu pliku musimy go doda do stage
git add <file_name>

# nastpnie wykonujemy commit
git commit -m "commit_message"

git rebase --continue
```

## .gitignore

Aby wykluczy pliki z repozytorium git nale偶y utworzy plik `.gitignore`



## Narzdzia
### VIM

> Edytowanie
```bash
a
```
> Wyjcie i zapisanie
```bash
:x
:wq
```

### Visual Studio Code
```bash
git config --global core.editor "code --wait"
```

## Praca z GIT

### Podstawkowe zasady
* Podczas wprowadzania nowej funkcjonalnoci tworzymy nowy `branch`
## Do Sprawdzenia

Gdy dodamy zmodyfikujemy plik bez dodania do staged `git add` mo偶emy wycofa zmiany `git restore <plik>`

Gdy dodamy pliki do `stage` za pomoc `git add <plik>` mo偶emy wycofa ten stage za pomoc `git restore --stage` a nastpnie przywr贸ci ich stan z ostatniej migawki za pomoc `git restore <plik>`

Przy korzystaniu z WSL i personal token na github konieczne podlinkowanie credential managera z windowsa do debiana
```bash
git config --global credential.helper "/mnt/c/Program\ Files/Git/mingw64/libexec/git-core/git-credential-manager.exe"
```
C:\Users\kudzi\OneDrive\Dokumenty\WindowsPowerShell\Modules\oh-my-posh\3.175.0\themes
